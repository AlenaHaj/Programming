#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

//ostream& operator<< (ostream& out, const vector<int> vect) {
ostream& operator<< (ostream& out, const vector<int>& vect) {

	out << vect.size() << "\t" << "| ";
	for (int i = 0; i < vect.size(); i++) out << &vect[i] << " ";
	return out;
}

int main()
{
	vector<int> vect;
	ofstream data_txt("data_1.txt");

	for (int i = 0; i < 64; i++) {
		vect.push_back(i);
		data_txt << vect << endl;
	}

	for (int i = 0; i < 64; i++) {
		vect.pop_back();
		data_txt << vect << endl;
	}

}

//
//При передаче вектора по ссылке адрес начала вектора меняется не постоянно, а доходит до определенного
//значения своего размера и потом сразу начинается с другого адреса. Иногда начало перемещается в тот
//адрес, где оно уже было раньше.
//Мне кажется, что вектору выделяется какой-то размер памяти и, пока он его не превысил, он находится
//по старому адресу. На сколько каждый раз увеличивается его максимальный размер точно сказать
//не могу, но где-то примерно на половину.
//Ещё могу сказать, что адреса вектора от начала до конца идут всё время непрерывно по четыре байта
//(размер int). 
//
//Вопрос 2:
//Из вывода видно, что при увеличении вектора с размера 19 на 20 он меняет адрес своего начала,
//и находитс там аж до 28 элементов. Таким образом, если запомнить адрес нулевой ячейки 
//вектора при его длине 15 элементов, а затем внести изменения по запомненному адресу при длине 
//вектора 25 элементов, значение в vect[0] не поменяется.

//Когда уменьшаем размеры вектора, то адрес нулевой ячейки у него не изменяется.
//
//Я сохранила адреса вектора и при передаче по значению, но вывод об отличии по этим данным сделать
//сложно. Похоже, там тоже происходит изменение адреса нулевой ячейки по закономерности как и в
//первом случае.
//
